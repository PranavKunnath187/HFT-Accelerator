# interfaces.md (as implemented/described in the HFT Accelerator report)

## 1) Scope
This document specifies the interfaces between:
- **Host PC (“Exchange Simulator”)** ↔ **FPGA board**
- **Networking subsystem** ↔ **Parser**
- **Parser** ↔ **Order Book**
- **Order Book** ↔ **Trading Logic**
- **Trading Logic** ↔ **Networking subsystem** (outbound orders)

The report’s system is: **PC generates market-data feed → FPGA parses → updates order book → trading logic produces orders → FPGA sends orders back**.

---

## 2) High-level architecture
**Inbound path**
1. Host PC sends an **ITCH-formatted market-data stream** to the FPGA over Ethernet using **TCP/IP**.
2. The FPGA networking side delivers a **byte stream** into a **circular/ring buffer**.
3. A **Parser FSM** consumes bytes, decodes ITCH message boundaries, filters relevant message types, and emits **normalized “events”**.
4. Events update the **Order Book** (per-stock book instances managed by a wrapper).

**Outbound path**
1. Trading logic consumes book outputs (best prices / sizes).
2. Trading logic emits **orders**.
3. The FPGA networking side formats and transmits outbound orders using an **exchange-style outbound protocol (OUCH-style)** over Ethernet.

---

## 3) Terminology
- **Packet:** Ethernet frame carrying TCP/IP payload bytes.
- **Byte stream:** The ordered TCP payload bytes delivered to the parser.
- **ITCH message:** Exchange market-data message; each has a length/type/content structure.
- **Event:** Internal normalized representation of an ITCH update (ADD/CANCEL/DELETE/EXECUTE).
- **Order:** Internal representation of an order generated by trading logic.

---

## 4) Host PC ↔ FPGA (network transport)

### 4.1 Transport
- **Physical/link:** Ethernet
- **Network stack:** TCP/IP
- **Inbound protocol/content:** **NASDAQ ITCH** message stream (generated synthetically by the host PC)
- **Outbound protocol/content:** **OUCH-style** order messages (host receives/logs these)

> Note: The report describes the host PC as the “exchange,” generating ITCH messages and sending them to the FPGA.

### 4.2 Assumptions
- TCP provides in-order delivery (the parser treats input as an ordered byte stream).
- Message boundaries are defined by ITCH’s own length/type encoding; the parser does not rely on Ethernet frame boundaries.

---

## 5) Networking subsystem ↔ Parser (byte stream interface)

### 5.1 Interface style
- Networking block delivers received TCP payload bytes to the parser through a **buffered streaming interface**.
- The report references **AXI-stream style constraints** for how data is delivered to the parser (i.e., a valid/ready stream abstraction), with a **circular buffer** used to absorb bursts.

### 5.2 Data unit
- Unit = **1 byte** (8 bits) from the TCP payload stream.

### 5.3 Buffering
- **Circular (ring) buffer** between TCP receive and parser:
  - Write pointer advances as bytes arrive from networking.
  - Read pointer advances as parser consumes bytes.
  - Purpose: avoid data loss when bursts arrive faster than the parser can process.

### 5.4 Stream semantics (conceptual)
- **rx_byte_valid:** networking has at least one byte available for parser to consume
- **rx_byte_ready:** parser is ready to consume a byte this cycle
- **rx_byte_data[7:0]:** the next byte of the stream
- Parser consumes a byte on `rx_byte_valid && rx_byte_ready`.

(Exact signal names depend on implementation; the report’s key requirement is: *byte-accurate, buffered, backpressure-capable delivery*.)

---

## 6) Parser behavior + outputs

### 6.1 Parser responsibilities
- Treat input as a continuous **byte stream**.
- Decode ITCH messages using:
  - **message length**
  - **message type** (1-byte type code)
  - **message payload**
- Filter and emit only ITCH message types relevant to maintaining an order book. The report highlights support for:
  - **Add Order** (e.g., “A” / “F” style add messages)
  - **Execute / Trade** (e.g., “E” / “C” style)
  - **Cancel** (e.g., “X”)
  - **Delete** (e.g., “D”)

### 6.2 Parser output: normalized Event
The parser emits an internal “event” record to drive the order book.

**Event fields (conceptual)**
- `event_valid` : 1
- `event_ready` : 1 (order book can backpressure parser)
- `event_type`  : enum { ADD, CANCEL, DELETE, EXECUTE }
- `stock_id` / `symbol_id` : identifies which per-stock book receives the update
- `side` : { BID, ASK } (if applicable for that message)
- `price` : integer price representation (ITCH-native or normalized)
- `qty` : share quantity (integer)
- `order_id` : identifier used for cancel/delete/execute (ITCH-native order reference)

> The report’s order book design relies on order IDs for decrease/cancel behaviors and price/qty for adds/updates.

### 6.3 Event ordering
- Events must be emitted in the same order as in the TCP stream.

---

## 7) Parser ↔ Order Book

### 7.1 Interface style
- Event stream with valid/ready handshake:
  - `event_valid`, `event_ready`
  - fields listed above

### 7.2 Order book wrapper
- A top-level **order_book_wrapper** routes events to one of **N per-stock order books** (instantiated via generate/parameterization).
- Wrapper also aggregates per-stock “best price” outputs into arrays.

### 7.3 Backpressure / busy
- Order books can assert a “busy” condition while processing operations (particularly for delete/cancel logic that may scan memory).
- Wrapper/order book can backpressure parser via `event_ready`.

---

## 8) Order Book ↔ Trading Logic

### 8.1 Outputs provided by order book
At minimum, the trading module consumes:
- **Best price per stock** (best bid and/or best ask)
- **Validity flags** indicating best prices are meaningful

(Implementations may include best-size, spread, last-trade, etc., but the report emphasizes best-price extraction.)

### 8.2 Interface (conceptual)
- `best_price_stocks[N]` : array of best prices
- `best_prices_valid[N]` : validity bits

---

## 9) Trading Logic ↔ Networking (outbound orders)

### 9.1 Trading logic output: Order record
Trading logic emits orders to be transmitted back to the host (exchange client).

**Order fields (conceptual)**
- `order_valid`, `order_ready`
- `stock_id` / `symbol_id`
- `side` : buy/sell
- `price`
- `qty`
- optional: `order_type` (limit/market) depending on outbound protocol

### 9.2 Network formatting
- Outbound orders are formatted into **OUCH-style** messages and sent over the Ethernet/TCP path back to the host.

---

## 10) Observability / correctness checks
The report describes validating correctness by:
- comparing FPGA book state to a **Python reference** (software model)
- verifying behavior over Ethernet traffic capture / logging

Recommended counters to expose (even if not all are in the report):
- `bytes_rx`, `msgs_parsed`, `events_emitted`
- `ringbuf_overflow_count`
- `event_backpressure_cycles`
- `orders_tx`


