# interfaces.md (as implemented/described in the HFT Accelerator report)

## 1) Scope
This document specifies the interfaces between:
- **Host PC (“Exchange Simulator”)** ↔ **FPGA board**
- **Networking subsystem (MicroBlaze TCP/IP stack)** ↔ **Parser**
- **Parser** ↔ **Order Book**
- **Order Book** ↔ **Trading Logic**
- **Trading Logic** ↔ **Networking subsystem** (outbound orders)

The report’s system is: **PC generates market-data feed → FPGA parses → updates order book → trading logic produces orders → FPGA sends orders back**. :contentReference[oaicite:0]{index=0}

---

## 2) High-level architecture
### Inbound path
1. Host PC sends an **ITCH-formatted market-data stream** to the FPGA over Ethernet using **TCP/IP**. :contentReference[oaicite:1]{index=1}  
2. The Ethernet/TCP stack is built on **MicroBlaze**, which exposes data to FPGA fabric over **AXI-Stream**. :contentReference[oaicite:2]{index=2}  
3. The networking side delivers an ordered **byte stream** into a **circular/ring buffer** to absorb bursts. :contentReference[oaicite:3]{index=3}  
4. A **Parser FSM** consumes bytes, decodes ITCH message boundaries, filters relevant message types, and emits **normalized events** to the order book. :contentReference[oaicite:4]{index=4}  
5. Events update the **Order Book**.

### Outbound path
1. Trading logic consumes order-book outputs (best bid/ask snapshots). :contentReference[oaicite:5]{index=5}  
2. Trading logic emits **orders**.  
3. The system aims to transmit outbound orders back over the network (the report notes Ethernet integration issues for sending orders end-to-end in their build). :contentReference[oaicite:6]{index=6}  

---

## 3) Terminology
- **Packet:** Ethernet frame carrying TCP/IP payload bytes.
- **Byte stream:** The ordered TCP payload bytes delivered to the parser.
- **ITCH message:** Exchange market-data message with a **length/type/content** structure. :contentReference[oaicite:7]{index=7}
- **Event:** Internal normalized representation of an ITCH update (ADD/CANCEL/DELETE/EXECUTE).
- **Order:** Internal representation of an order generated by trading logic.
- **Backpressure:** downstream module temporarily unable to accept more input (e.g., order book busy), causing stalls. :contentReference[oaicite:8]{index=8}

---

## 4) Host PC ↔ FPGA (network transport)

### 4.1 Transport
- **Physical/link:** Ethernet
- **Network stack:** TCP/IP
- **Inbound protocol/content:** **NASDAQ ITCH** message stream (generated synthetically by the host PC as the “exchange”). :contentReference[oaicite:9]{index=9}

### 4.2 TCP stream assumptions (critical)
- TCP provides **in-order delivery**, but **not message boundaries**.
- The receiver may observe arbitrary chunking: partial messages or multiple messages together.
- Message boundaries are recovered using the ITCH **length/type/content** fields, not Ethernet frame boundaries. :contentReference[oaicite:10]{index=10}

### 4.3 ITCH message framing (paper-style) — Option A
The report describes ITCH messages as: **message length, message type, message content**. :contentReference[oaicite:11]{index=11}  
An example in the report shows:
- `0x13` labeled as **size of message** (length)
- `0x44` labeled as **'D'** (message type)
- remaining bytes are message content. :contentReference[oaicite:12]{index=12}

**Framing format**
- `[ LEN ][ TYPE ][ PAYLOAD ]`
- `LEN` is **1 byte**. :contentReference[oaicite:13]{index=13}  
- `TYPE` is **1 byte**. :contentReference[oaicite:14]{index=14}  

**Option A (chosen):** `LEN = bytes(TYPE + PAYLOAD)`  
Therefore: `PAYLOAD_LEN = LEN - 1`.

---

## 5) Networking subsystem ↔ Parser (byte stream interface)

### 5.1 Interface style
- Ethernet stack is implemented on **MicroBlaze**.
- Communication between MicroBlaze and FPGA fabric uses **AXI-Stream**, so the parser must accept data in an AXI-stream-like valid/ready style. :contentReference[oaicite:15]{index=15}
- The report explicitly notes the input may be **invalid for some cycles**, and the parser must safely make **no progress** during those cycles. :contentReference[oaicite:16]{index=16}

### 5.2 Data unit (byte granularity)
The report argues the natural granularity is **one byte**, because ITCH message type is a byte and byte granularity simplifies the parser FSM. :contentReference[oaicite:17]{index=17}  
So the logical unit delivered to the parser is:
- `rx_byte_data[7:0]`

### 5.3 Buffering
To avoid drops during bursty traffic, the report proposes a **ring buffer** in hardware:
- it stores incoming bytes,
- attempts to dequeue every cycle,
- and feeds the parser **unless the parser stalls due to backpressure from the book**. :contentReference[oaicite:18]{index=18}  
The report also mentions an alternative: implement a circular buffer in MicroBlaze C. :contentReference[oaicite:19]{index=19}

### 5.4 Stream semantics (conceptual)
- `rx_byte_valid`: there is a byte available
- `rx_byte_ready`: parser can accept a byte
- consume occurs on `valid && ready`  
This matches the “input may be invalid” and “stall safely” requirement from the report. :contentReference[oaicite:20]{index=20}

---

## 6) Parser behavior + outputs

### 6.1 Parser responsibilities
- Treat input as a continuous **byte stream**. :contentReference[oaicite:21]{index=21}
- Recover ITCH message boundaries using the framing rule:
  - read 1-byte `LEN`
  - read 1-byte `TYPE`
  - read `LEN-1` bytes of payload (Option A)
- Filter and forward only order-book-relevant ITCH messages (below). :contentReference[oaicite:22]{index=22}

### 6.2 Pertinent ITCH message types (exact list from report)
The report lists the relevant messages for book maintenance as: :contentReference[oaicite:23]{index=23}
- Add Order: **'A' = 0x41**
- Add Order w/ MPID attribution: **'F' = 0x46**
- Order Executed: **'E' = 0x45**
- Order Executed w/ Price: **'C' = 0x43**
- Order Cancel: **'X' = 0x58**
- Order Delete: **'D' = 0x44**
- Order Replace: **'U' = 0x55**

Initial implementation: **supports all except Replace ('U')**, with the report suggesting Replace can be approximated as cancel+add (with caveats about intermediate state). :contentReference[oaicite:24]{index=24}

### 6.3 Parser output: normalized Event (conceptual)
The parser emits an internal “event” record to drive the order book (report-level description; exact bit widths depend on implementation):
- `event_valid` / `event_ready`
- `event_type`: { ADD, EXECUTE, CANCEL, DELETE } (and optionally REPLACE if later supported)
- `stock_id` / `symbol_id`
- `side`
- `price`
- `qty`
- `order_id` (needed for cancel/delete/execute semantics)

The intent is: parser passes these messages to the order book while filtering all other ITCH messages. :contentReference[oaicite:25]{index=25}

### 6.4 Event ordering
Events must be emitted in the same order as the TCP stream.

---

## 7) Parser ↔ Order Book

### 7.1 Interface style
- Event stream with valid/ready handshake:
  - `event_valid`, `event_ready`
  - fields as defined in Section 6.3

### 7.2 Backpressure / busy (paper motivation)
The ring buffer dequeues every cycle **unless the parser is stalling because of backpressure from the book**, which makes book throughput the limiting factor during bursts. :contentReference[oaicite:26]{index=26}

---

## 8) Order Book ↔ Trading Logic

### 8.1 Outputs provided by order book
At minimum, the report expects the book to expose:
- **best bid and ask prices** per stock (and validity)
- snapshots of market state for trading logic consumption. :contentReference[oaicite:27]{index=27} :contentReference[oaicite:28]{index=28}

### 8.2 Interface (conceptual)
- `best_bid_price[NUM_STOCKS]`
- `best_ask_price[NUM_STOCKS]`
- `best_valid[NUM_STOCKS]`

---

## 9) Trading Logic ↔ Networking (outbound orders)

### 9.1 Trading logic output: Order record (conceptual)
Trading logic produces orders to be sent back out over the network.

### 9.2 Network formatting / status (as reported)
The report indicates trading logic should interface with the Ethernet stack to send orders over TCP, but notes this integration was not fully successful in their build. :contentReference[oaicite:29]{index=29}

---

## 10) Observability / correctness checks
The report verifies correctness by cross-checking output over Ethernet and by comparing order-book state against a Python model during simulation. :contentReference[oaicite:30]{index=30} :contentReference[oaicite:31]{index=31}

Recommended counters to expose:
- `bytes_rx`
- `msgs_parsed`
- `events_emitted`
- `ringbuf_overflow_count`
- `event_backpressure_cycles`
- `orders_tx`
